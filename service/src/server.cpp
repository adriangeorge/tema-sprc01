/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "server.h"
#include "interface.h"
#include <fstream>
#include <iostream>
#include <sstream>

std::map<std::string, user> user_db;
std::map<std::string, token> token_db;
std::set<std::string> resource_db;
std::vector<std::map<std::string, unsigned char>> user_approvals;
int current_approval_index = 0;
int token_availability = 0;

#define __DEBUG__
void server_init(std::string client_f, std::string resource_f,
		 std::string approval_f, int avail)
{
	// Set token availabilty
	token_availability = avail;
	// Read and store client info
	std::ifstream client_file(client_f);

	int client_count;
	client_file >> client_count;
	std::string user_id;
	while (client_file >> user_id) {
		user new_user;
		new_user.curr_token = "N/A";
		user_db.insert(std::pair<std::string, user>(user_id, new_user));

#ifdef __DEBUG__
		std::cout << "[UserDB] Inserted " << user_id << " with token "
			  << user_db.at(user_id).curr_token << std::endl;
#endif
	}

	client_file.close();

	std::cout << std::endl;

	// Read and store resource info
	std::ifstream resource_file(resource_f);
	int res_count;
	resource_file >> res_count;
	std::string res_name;
	while (resource_file >> res_name) {
		resource_db.insert(res_name);

#ifdef __DEBUG__
		std::cout << "[ResDB] Inserted "
			  << *(resource_db.find(res_name)) << std::endl;
#endif
	}

	resource_file.close();
	std::cout << std::endl;

	// Read and store approval info
#ifdef __DEBUG__
	std::cout << "[PermDB] Begin " << std::endl;
#endif
	std::ifstream approval_file(approval_f);
	std::string app_name;
	while (approval_file >> app_name) {
		std::map<std::string, unsigned char> new_approval;

		std::stringstream s(app_name);
		std::string csv_res_name, csv_perm;

		// For each specified permission grab a pair of
		// (res_name, perm_str) And determine permission value
		while (getline(s, csv_res_name, ',')) {
			// If no permissions are allowed no point in assigning
			// to permission map
			if (csv_res_name == "*") {
				getline(s, csv_perm, ',');
				continue;
			}
			unsigned char new_perm = 0;
			getline(s, csv_perm, ',');

			// Search each permission type and perform binary OR
			for (int i = 0; i < csv_perm.length(); i++) {
				if (csv_perm[i] == 'R') {
					new_perm |= READ;
				} else if (csv_perm[i] == 'I') {
					new_perm |= INSERT;
				} else if (csv_perm[i] == 'M') {
					new_perm |= MODIFY;
				} else if (csv_perm[i] == 'D') {
					new_perm |= DELETE;
				} else if (csv_perm[i] == 'X') {
					new_perm |= EXECUTE;
				}
			}

			auto perm_pair = std::pair<std::string, unsigned char>(
			    csv_res_name, new_perm);

			new_approval.insert(perm_pair);

			std::cout
			    << "[" << csv_res_name << "] | ["
			    << std::to_string(new_approval.at(csv_res_name))
			    << "]" << std::endl;
		}

		std::cout << std::endl;
		user_approvals.push_back(new_approval);
	}
#ifdef __DEBUG__
		std::cout << "[PermDB] Finished " << std::endl;
#endif

	approval_file.close();
}

server_res_token *req_auth_1_svc(client_req_auth *argp, struct svc_req *rqstp)
{
	static server_res_token result;

	/*
	 * insert server code here
	 */

	return &result;
}

server_res_token *approve_req_token_1_svc(client_req_approve *argp,
					  struct svc_req *rqstp)
{
	static server_res_token result;

	/*
	 * insert server code here
	 */

	return &result;
}

server_res_token *req_bearer_token_1_svc(client_req_access *argp,
					 struct svc_req *rqstp)
{
	static server_res_token result;

	/*
	 * insert server code here
	 */

	return &result;
}

server_res_token *req_bearer_token_refresh_1_svc(client_req_access *argp,
						 struct svc_req *rqstp)
{
	static server_res_token result;

	/*
	 * insert server code here
	 */

	return &result;
}

server_res_token *validate_delegated_action_1_svc(client_req_op *argp,
						  struct svc_req *rqstp)
{
	static server_res_token result;

	/*
	 * insert server code here
	 */

	return &result;
}
